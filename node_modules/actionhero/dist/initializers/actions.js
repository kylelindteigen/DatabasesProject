"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const glob = require("glob");
const path = require("path");
const index_1 = require("../index");
class Actions extends index_1.Initializer {
    constructor() {
        super();
        this.name = "actions";
        this.loadPriority = 410;
    }
    async initialize(config) {
        index_1.api.actions = {
            actions: {},
            versions: {},
            middleware: {},
            globalMiddleware: [],
        };
        index_1.api.actions.loadFile = async (fullFilePath, reload = false) => {
            const loadMessage = (action) => {
                if (reload) {
                    index_1.log(`action reloaded: ${action.name} @ v${action.version}, ${fullFilePath}`, "info");
                }
                else {
                    index_1.log(`action loaded: ${action.name} @ v${action.version}, ${fullFilePath}`, "debug");
                }
            };
            let action;
            try {
                let collection = require(fullFilePath);
                if (typeof collection === "function") {
                    collection = [collection];
                }
                for (const i in collection) {
                    action = new collection[i]();
                    await action.validate(index_1.api);
                    if (!index_1.api.actions.actions[action.name]) {
                        index_1.api.actions.actions[action.name] = {};
                    }
                    if (!index_1.api.actions.versions[action.name]) {
                        index_1.api.actions.versions[action.name] = [];
                    }
                    if (index_1.api.actions.actions[action.name][action.version] && !reload) {
                        index_1.log(`an existing action with the same name \`${action.name}\` will be overridden by the file ${fullFilePath}`, "warning");
                    }
                    index_1.api.actions.actions[action.name][action.version] = action;
                    index_1.api.actions.versions[action.name].push(action.version);
                    index_1.api.actions.versions[action.name].sort();
                    loadMessage(action);
                }
            }
            catch (error) {
                try {
                    index_1.api.exceptionHandlers.loader(fullFilePath, error);
                    delete index_1.api.actions.actions[action.name][action.version];
                }
                catch (_error) {
                    throw error;
                }
            }
        };
        for (const i in config.general.paths.action) {
            const p = config.general.paths.action[i];
            let files = glob.sync(path.join(p, "**", "**/*(*.js|*.ts)"));
            files = index_1.utils.ensureNoTsHeaderFiles(files);
            for (const j in files) {
                await index_1.api.actions.loadFile(files[j]);
            }
        }
        for (const pluginName in config.plugins) {
            if (config.plugins[pluginName].actions !== false) {
                const pluginPath = config.plugins[pluginName].path;
                // old style at the root of the project
                let files = glob.sync(path.join(pluginPath, "actions", "**", "*.js"));
                files = files.concat(glob.sync(path.join(pluginPath, "dist", "actions", "**", "*.js")));
                index_1.utils
                    .ensureNoTsHeaderFiles(files)
                    .forEach((f) => index_1.api.actions.loadFile(f));
            }
        }
    }
}
exports.Actions = Actions;
