"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Resque = void 0;
const node_resque_1 = require("node-resque");
const index_1 = require("../index");
/**
 * The node-resque workers and scheduler which process tasks.
 * see https://github.com/actionhero/node-resque
 */
class Resque extends index_1.Initializer {
    constructor() {
        super();
        this.name = "resque";
        this.loadPriority = 600;
        this.startPriority = 200;
        this.stopPriority = 100;
    }
    filterTaskParams(params) {
        const filteredParams = Object.assign({}, params);
        for (const key in params) {
            if (index_1.config.general.filteredParams.indexOf(key) >= 0) {
                filteredParams[key] = "[FILTERED]";
            }
        }
        return filteredParams;
    }
    async initialize(config) {
        if (config.redis.enabled === false) {
            return;
        }
        const resqueOverrides = config.tasks.resque_overrides;
        index_1.api.resque = {
            queue: null,
            multiWorker: null,
            scheduler: null,
            connectionDetails: Object.assign({}, config.tasks.connectionOptions.tasks, {
                redis: index_1.api.redis.clients.tasks,
            }),
            startQueue: async () => {
                let ActionheroQueue = node_resque_1.Queue;
                if (resqueOverrides && resqueOverrides.queue) {
                    ActionheroQueue = resqueOverrides.queue;
                }
                index_1.api.resque.queue = new ActionheroQueue({ connection: index_1.api.resque.connectionDetails }, index_1.api.tasks.jobs);
                index_1.api.resque.queue.on("error", (error) => {
                    index_1.log(error.toString(), "error", "[api.resque.queue]");
                });
                await index_1.api.resque.queue.connect();
            },
            stopQueue: async () => {
                if (index_1.api.resque.queue) {
                    return index_1.api.resque.queue.end();
                }
            },
            startScheduler: async () => {
                let ActionheroScheduler = node_resque_1.Scheduler;
                if (resqueOverrides && resqueOverrides.scheduler) {
                    ActionheroScheduler = resqueOverrides.scheduler;
                }
                if (config.tasks.scheduler === true) {
                    index_1.api.resque.schedulerLogging = config.tasks.schedulerLogging;
                    index_1.api.resque.scheduler = new ActionheroScheduler({
                        connection: index_1.api.resque.connectionDetails,
                        timeout: config.tasks.timeout,
                        stuckWorkerTimeout: config.tasks.stuckWorkerTimeout,
                    });
                    index_1.api.resque.scheduler.on("error", (error) => {
                        index_1.log(error.toString(), "error", "[api.resque.scheduler]");
                    });
                    await index_1.api.resque.scheduler.connect();
                    index_1.api.resque.scheduler.on("start", () => {
                        index_1.log("resque scheduler started", index_1.api.resque.schedulerLogging.start);
                    });
                    index_1.api.resque.scheduler.on("end", () => {
                        index_1.log("resque scheduler ended", index_1.api.resque.schedulerLogging.end);
                    });
                    index_1.api.resque.scheduler.on("poll", () => {
                        index_1.log("resque scheduler polling", index_1.api.resque.schedulerLogging.poll);
                    });
                    index_1.api.resque.scheduler.on("leader", () => {
                        index_1.log("This node is now the Resque scheduler leader", "notice");
                    });
                    index_1.api.resque.scheduler.on("cleanStuckWorker", (workerName, errorPayload, delta) => {
                        index_1.log("cleaned stuck worker", "warning", {
                            workerName,
                            errorPayload,
                            delta,
                        });
                    });
                    index_1.api.resque.scheduler.start();
                }
            },
            stopScheduler: async () => {
                if (index_1.api.resque.scheduler) {
                    return index_1.api.resque.scheduler.end();
                }
            },
            startMultiWorker: async () => {
                let ActionheroMultiWorker = node_resque_1.MultiWorker;
                if (resqueOverrides && resqueOverrides.multiWorker) {
                    ActionheroMultiWorker = resqueOverrides.multiWorker;
                }
                index_1.api.resque.workerLogging = config.tasks.workerLogging;
                index_1.api.resque.schedulerLogging = config.tasks.schedulerLogging;
                index_1.api.resque.multiWorker = new ActionheroMultiWorker({
                    connection: index_1.api.resque.connectionDetails,
                    queues: config.tasks.queues,
                    timeout: config.tasks.timeout,
                    checkTimeout: config.tasks.checkTimeout,
                    minTaskProcessors: config.tasks.minTaskProcessors,
                    maxTaskProcessors: config.tasks.maxTaskProcessors,
                    maxEventLoopDelay: config.tasks.maxEventLoopDelay,
                }, index_1.api.tasks.jobs);
                // normal worker emitters
                index_1.api.resque.multiWorker.on("start", (workerId) => {
                    index_1.log("[ worker ] started", index_1.api.resque.workerLogging.start, {
                        workerId,
                    });
                });
                index_1.api.resque.multiWorker.on("end", (workerId) => {
                    index_1.log("[ worker ] ended", index_1.api.resque.workerLogging.end, {
                        workerId,
                    });
                });
                index_1.api.resque.multiWorker.on("cleaning_worker", (workerId, worker, pid) => {
                    index_1.log(`[ worker ] cleaning old worker ${worker}, (${pid})`, index_1.api.resque.workerLogging.cleaning_worker);
                });
                index_1.api.resque.multiWorker.on("poll", (workerId, queue) => {
                    index_1.log(`[ worker ] polling ${queue}`, index_1.api.resque.workerLogging.poll, {
                        workerId,
                    });
                });
                index_1.api.resque.multiWorker.on("job", (workerId, queue, job) => {
                    index_1.log(`[ worker ] working job ${queue}`, index_1.api.resque.workerLogging.job, {
                        workerId,
                        class: job.class,
                        queue: job.queue,
                        args: JSON.stringify(this.filterTaskParams(job.args[0])),
                    });
                });
                index_1.api.resque.multiWorker.on("reEnqueue", (workerId, queue, job, plugin) => {
                    index_1.log("[ worker ] reEnqueue task", index_1.api.resque.workerLogging.reEnqueue, {
                        workerId,
                        plugin: JSON.stringify(plugin),
                        class: job.class,
                        queue: job.queue,
                    });
                });
                index_1.api.resque.multiWorker.on("pause", (workerId) => {
                    index_1.log("[ worker ] paused", index_1.api.resque.workerLogging.pause, {
                        workerId,
                    });
                });
                index_1.api.resque.multiWorker.on("failure", (workerId, queue, job, failure) => {
                    index_1.api.exceptionHandlers.task(failure, queue, job, workerId);
                });
                index_1.api.resque.multiWorker.on("error", (error, workerId, queue, job) => {
                    index_1.api.exceptionHandlers.task(error, queue, job, workerId);
                });
                index_1.api.resque.multiWorker.on("success", (workerId, queue, job, result, duration) => {
                    const payload = {
                        workerId,
                        class: job.class,
                        queue: job.queue,
                        args: JSON.stringify(this.filterTaskParams(job.args[0])),
                        result,
                        duration,
                    };
                    index_1.log("[ worker ] task success", index_1.api.resque.workerLogging.success, payload);
                });
                // multiWorker emitters
                index_1.api.resque.multiWorker.on("multiWorkerAction", (verb, delay) => {
                    index_1.log(`[ multiworker ] checked for worker status: ${verb} (event loop delay: ${delay}ms)`, index_1.api.resque.workerLogging.multiWorkerAction);
                });
                if (config.tasks.minTaskProcessors > 0) {
                    index_1.api.resque.multiWorker.start();
                }
            },
            stopMultiWorker: async () => {
                if (index_1.api.resque.multiWorker && config.tasks.minTaskProcessors > 0) {
                    return index_1.api.resque.multiWorker.stop();
                }
            },
        };
    }
    async start(config) {
        if (config.redis.enabled === false) {
            return;
        }
        if (config.tasks.minTaskProcessors === 0 &&
            config.tasks.maxTaskProcessors > 0) {
            config.tasks.minTaskProcessors = 1;
        }
        await index_1.api.resque.startQueue();
        await index_1.api.resque.startScheduler();
        await index_1.api.resque.startMultiWorker();
    }
    async stop(config) {
        if (config.redis.enabled === false) {
            return;
        }
        await index_1.api.resque.stopScheduler();
        await index_1.api.resque.stopMultiWorker();
        await index_1.api.resque.stopQueue();
    }
}
exports.Resque = Resque;
