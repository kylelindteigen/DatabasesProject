"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Servers = void 0;
const path = require("path");
const glob = require("glob");
const index_1 = require("../index");
/**
 * Manages the servers in this Actionhero instance.
 */
class Servers extends index_1.Initializer {
    constructor() {
        super();
        this.name = "servers";
        this.loadPriority = 599;
        this.startPriority = 900;
        this.stopPriority = 100;
    }
    async initialize(config) {
        index_1.api.servers = {
            servers: {},
        };
        const serverFolders = [path.resolve(path.join(__dirname, "..", "servers"))];
        config.general.paths.server.forEach((p) => {
            p = path.resolve(p);
            if (serverFolders.indexOf(p) < 0) {
                serverFolders.push(p);
            }
        });
        let files = [];
        for (const i in serverFolders) {
            const p = serverFolders[i];
            files = files.concat(glob.sync(path.join(p, "**", "**/*(*.js|*.ts)")));
        }
        for (const pluginName in config.plugins) {
            if (config.plugins[pluginName].servers !== false) {
                const pluginPath = config.plugins[pluginName].path;
                // old style at the root of the project
                files = files.concat(glob.sync(path.join(pluginPath, "servers", "**", "*.js")));
                files = files.concat(glob.sync(path.join(pluginPath, "dist", "servers", "**", "*.js")));
            }
        }
        files = index_1.utils.ensureNoTsHeaderFiles(files);
        let server;
        for (const j in files) {
            const filename = files[j];
            const ExportedClasses = require(filename);
            const exportLen = Object.keys(ExportedClasses).length;
            // we have named exports
            if (exportLen) {
                if (exportLen > 1) {
                    throw new Error(`server file ${filename} exports more than one server`);
                }
                server = new ExportedClasses[Object.keys(ExportedClasses)[0]]();
            }
            else {
                // there is one default export
                server = new ExportedClasses();
            }
            server.config = config.servers[server.type]; // for shorthand access
            if (server.config && server.config.enabled === true) {
                await server.initialize();
                if (index_1.api.servers.servers[server.type]) {
                    index_1.log(`an existing server with the same type \`${server.type}\` will be overridden by the file ${filename}`, "crit");
                }
                index_1.api.servers.servers[server.type] = server;
                index_1.log(`Initialized server: ${server.type}`, "debug");
            }
        }
    }
    async start(config) {
        const serverNames = Object.keys(index_1.api.servers.servers);
        for (const i in serverNames) {
            const serverName = serverNames[i];
            const server = index_1.api.servers.servers[serverName];
            if (server && server.config.enabled === true) {
                let message = "";
                message += `Starting server: \`${serverName}\``;
                if (config.servers[serverName].bindIP) {
                    message += ` @ ${config.servers[serverName].bindIP}`;
                }
                if (config.servers[serverName].port) {
                    message += `:${config.servers[serverName].port}`;
                }
                index_1.log(message, "notice");
                await server.start();
                index_1.log(`Server started: ${serverName}`, "debug");
            }
        }
    }
    async stop() {
        const serverNames = Object.keys(index_1.api.servers.servers);
        for (const i in serverNames) {
            const serverName = serverNames[i];
            const server = index_1.api.servers.servers[serverName];
            if ((server && server.config.enabled === true) || !server) {
                index_1.log(`Stopping server: ${serverName}`, "notice");
                await server.stop();
                server.removeAllListeners();
                index_1.log(`Server stopped: ${serverName}`, "debug");
            }
        }
    }
}
exports.Servers = Servers;
