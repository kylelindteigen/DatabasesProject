"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const Mime = require("mime");
const index_1 = require("../index");
async function asyncStats(file) {
    return new Promise((resolve, reject) => {
        fs.stat(file, (error, stats) => {
            if (error) {
                return reject(error);
            }
            return resolve(stats);
        });
    });
}
async function asyncReadLink(file) {
    return new Promise((resolve, reject) => {
        fs.readlink(file, (error, linkString) => {
            if (error) {
                return reject(error);
            }
            return resolve(linkString);
        });
    });
}
/**
 * Countains helpers for returning flies to connections.
 */
class StaticFile extends index_1.Initializer {
    constructor() {
        super();
        this.name = "staticFile";
        this.loadPriority = 510;
    }
    async initialize(config) {
        index_1.api.staticFile = {
            searchLocations: [],
        };
        /**
         * For a connection with `connection.params.file` set, return a file if we can find it, or a not-found message.
         * `searchLocations` will be checked in the following order: first paths in this project, then plugins.
         * This can be used in Actions to return files to clients.  If done, set `data.toRender = false` within the action.
         * return is of the form: {connection, error, fileStream, mime, length}
         */
        index_1.api.staticFile.get = async (connection, counter = 0) => {
            let file;
            if (!connection.params.file || !index_1.api.staticFile.searchPath(counter)) {
                return index_1.api.staticFile.sendFileNotFound(connection, await config.errors.fileNotProvided(connection));
            }
            if (!path.isAbsolute(connection.params.file)) {
                file = path.normalize(path.join(index_1.api.staticFile.searchPath(counter), connection.params.file));
            }
            else {
                file = connection.params.file;
            }
            if (file.indexOf(path.normalize(index_1.api.staticFile.searchPath(counter))) !== 0) {
                return index_1.api.staticFile.get(connection, counter + 1);
            }
            else {
                const { exists, truePath } = await index_1.api.staticFile.checkExistence(file);
                if (exists) {
                    return index_1.api.staticFile.sendFile(truePath, connection);
                }
                else {
                    return index_1.api.staticFile.get(connection, counter + 1);
                }
            }
        };
        index_1.api.staticFile.searchPath = (counter = 0) => {
            if (index_1.api.staticFile.searchLocations.length === 0 ||
                counter >= index_1.api.staticFile.searchLocations.length) {
                return null;
            }
            else {
                return index_1.api.staticFile.searchLocations[counter];
            }
        };
        index_1.api.staticFile.sendFile = async (file, connection) => {
            let lastModified;
            try {
                const stats = await asyncStats(file);
                const mime = Mime.getType(file);
                const length = stats.size;
                const start = new Date().getTime();
                lastModified = stats.mtime;
                const fileStream = fs.createReadStream(file);
                index_1.api.staticFile.fileLogger(fileStream, connection, start, file, length);
                await new Promise((resolve) => {
                    fileStream.on("open", () => {
                        resolve();
                    });
                });
                return { connection, fileStream, mime, length, lastModified };
            }
            catch (error) {
                return index_1.api.staticFile.sendFileNotFound(connection, await config.errors.fileReadError(connection, String(error)));
            }
        };
        index_1.api.staticFile.fileLogger = (fileStream, connection, start, file, length) => {
            fileStream.on("end", () => {
                const duration = new Date().getTime() - start;
                index_1.api.staticFile.logRequest(file, connection, length, duration, true);
            });
            fileStream.on("error", (error) => {
                throw error;
            });
        };
        index_1.api.staticFile.sendFileNotFound = async (connection, errorMessage) => {
            connection.error = new Error(errorMessage);
            index_1.api.staticFile.logRequest("{not found}", connection, null, null, false);
            return {
                connection,
                error: await config.errors.fileNotFound(connection),
                mime: "text/html",
                length: await config.errors.fileNotFound(connection).length,
            };
        };
        index_1.api.staticFile.checkExistence = async (file) => {
            try {
                const stats = await asyncStats(file);
                if (stats.isDirectory()) {
                    const indexPath = file + "/" + config.general.directoryFileType;
                    return index_1.api.staticFile.checkExistence(indexPath);
                }
                if (stats.isSymbolicLink()) {
                    let truePath = await asyncReadLink(file);
                    truePath = path.normalize(truePath);
                    return index_1.api.staticFile.checkExistence(truePath);
                }
                if (stats.isFile()) {
                    return { exists: true, truePath: file };
                }
                return { exists: false, truePath: file };
            }
            catch (error) {
                return { exists: false, truePath: file };
            }
        };
        index_1.api.staticFile.logRequest = (file, connection, length, duration, success) => {
            index_1.log(`[ file @ ${connection.type} ]`, config.general.fileRequestLogLevel, {
                to: connection.remoteIP,
                file: file,
                requestedFile: connection.params.file,
                size: length,
                duration: duration,
                success: success,
            });
        };
        // load in the explicit public paths first
        if (config.general.paths !== undefined) {
            config.general.paths.public.forEach(function (p) {
                index_1.api.staticFile.searchLocations.push(path.normalize(p));
            });
        }
        // source the public directories from plugins
        for (const pluginName in config.plugins) {
            if (config.plugins[pluginName].public !== false) {
                const pluginPublicPath = path.join(config.plugins[pluginName].path, "public");
                if (fs.existsSync(pluginPublicPath) &&
                    index_1.api.staticFile.searchLocations.indexOf(pluginPublicPath) < 0) {
                    index_1.api.staticFile.searchLocations.push(pluginPublicPath);
                }
            }
        }
        index_1.log("static files will be served from these directories", "debug", index_1.api.staticFile.searchLocations);
    }
}
exports.StaticFile = StaticFile;
