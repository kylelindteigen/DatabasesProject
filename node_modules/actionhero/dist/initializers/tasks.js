"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const glob = require("glob");
const path = require("path");
const node_resque_1 = require("node-resque");
const index_1 = require("../index");
const taskModule = index_1.task;
/**
 * Tools for enqueuing and inspecting the task system (delayed jobs).
 */
class Tasks extends index_1.Initializer {
    constructor() {
        super();
        this.name = "tasks";
        this.loadPriority = 699;
        this.startPriority = 900;
    }
    async initialize(config) {
        index_1.api.tasks = {
            tasks: {},
            jobs: {},
            middleware: {},
            globalMiddleware: [],
        };
        index_1.api.tasks.loadFile = (fullFilePath, reload = false) => {
            let task;
            let collection = require(fullFilePath);
            for (const i in collection) {
                const TaskClass = collection[i];
                task = new TaskClass();
                task.validate();
                if (index_1.api.tasks.tasks[task.name] && !reload) {
                    index_1.log(`an existing task with the same name \`${task.name}\` will be overridden by the file ${fullFilePath}`, "crit");
                }
                index_1.api.tasks.tasks[task.name] = task;
                index_1.api.tasks.jobs[task.name] = index_1.api.tasks.jobWrapper(task.name);
                index_1.log(`task ${reload ? "(re)" : ""} loaded: ${task.name}, ${fullFilePath}`, "debug");
            }
        };
        index_1.api.tasks.jobWrapper = (taskName) => {
            const task = index_1.api.tasks.tasks[taskName];
            const middleware = task.middleware || [];
            const plugins = task.plugins || [];
            const pluginOptions = task.pluginOptions || {};
            if (task.frequency > 0) {
                if (plugins.indexOf("JobLock") < 0) {
                    plugins.push("JobLock");
                }
                if (plugins.indexOf("QueueLock") < 0) {
                    plugins.push("QueueLock");
                }
                if (plugins.indexOf("DelayQueueLock") < 0) {
                    plugins.push("DelayQueueLock");
                }
            }
            // load middleware into plugins
            const processMiddleware = (m) => {
                if (index_1.api.tasks.middleware[m]) {
                    //@ts-ignore
                    class NodeResquePlugin extends node_resque_1.Plugin {
                        constructor(...args) {
                            //@ts-ignore
                            super(...args);
                            if (index_1.api.tasks.middleware[m].preProcessor) {
                                //@ts-ignore
                                this.beforePerform = index_1.api.tasks.middleware[m].preProcessor;
                            }
                            if (index_1.api.tasks.middleware[m].postProcessor) {
                                //@ts-ignore
                                this.afterPerform = index_1.api.tasks.middleware[m].postProcessor;
                            }
                            if (index_1.api.tasks.middleware[m].preEnqueue) {
                                //@ts-ignore
                                this.beforeEnqueue = index_1.api.tasks.middleware[m].preEnqueue;
                            }
                            if (index_1.api.tasks.middleware[m].postEnqueue) {
                                //@ts-ignore
                                this.afterEnqueue = index_1.api.tasks.middleware[m].postEnqueue;
                            }
                        }
                    }
                    plugins.push(NodeResquePlugin);
                }
            };
            index_1.api.tasks.globalMiddleware.forEach(processMiddleware);
            middleware.forEach(processMiddleware);
            return {
                plugins,
                pluginOptions,
                perform: async function () {
                    const combinedArgs = [].concat(Array.prototype.slice.call(arguments));
                    combinedArgs.push(this);
                    let response = null;
                    try {
                        response = await task.run.apply(task, combinedArgs);
                        await taskModule.enqueueRecurrentTask(taskName);
                    }
                    catch (error) {
                        if (task.frequency > 0 && task.reEnqueuePeriodicTaskIfException) {
                            await taskModule.enqueueRecurrentTask(taskName);
                        }
                        throw error;
                    }
                    return response;
                },
            };
        };
        index_1.api.tasks.loadTasks = (reload) => {
            config.general.paths.task.forEach((p) => {
                index_1.utils
                    .ensureNoTsHeaderFiles(glob.sync(path.join(p, "**", "**/*(*.js|*.ts)")))
                    .forEach((f) => {
                    index_1.api.tasks.loadFile(f, reload);
                });
            });
            for (const pluginName in config.plugins) {
                if (config.plugins[pluginName].tasks !== false) {
                    const pluginPath = config.plugins[pluginName].path;
                    // old style at the root of the project
                    let files = glob.sync(path.join(pluginPath, "tasks", "**", "*.js"));
                    files = files.concat(glob.sync(path.join(pluginPath, "dist", "tasks", "**", "*.js")));
                    index_1.utils.ensureNoTsHeaderFiles(files).forEach((f) => {
                        index_1.api.tasks.loadFile(f, reload);
                    });
                }
            }
        };
        index_1.api.tasks.loadTasks(false);
    }
    async start(config) {
        if (config.redis.enabled === false) {
            return;
        }
        if (config.tasks.scheduler === true) {
            await taskModule.enqueueAllRecurrentTasks();
        }
    }
}
exports.Tasks = Tasks;
