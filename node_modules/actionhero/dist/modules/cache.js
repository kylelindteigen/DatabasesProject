"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const index_1 = require("../index");
var cache;
(function (cache) {
    cache.redisPrefix = index_1.config.general.cachePrefix;
    cache.lockPrefix = index_1.config.general.lockPrefix;
    cache.lockDuration = index_1.config.general.lockDuration;
    cache.lockRetry = 100;
    function client() {
        if (index_1.config.redis.enabled && index_1.api.redis.clients && index_1.api.redis.clients.client) {
            return index_1.api.redis.clients.client;
        }
        else {
            throw new Error("redis not connected, cache cannot be used");
        }
    }
    cache.client = client;
    let lockNameOverride;
    function lockName() {
        if (lockNameOverride) {
            return lockNameOverride;
        }
        return index_1.id;
    }
    cache.lockName = lockName;
    function overrideLockName(name) {
        lockNameOverride = name;
    }
    cache.overrideLockName = overrideLockName;
    /**
     * Returns all the keys in redis which are under this Actionhero namespace.  Potentially very slow.
     */
    async function keys() {
        return client().keys(cache.redisPrefix + "*");
    }
    cache.keys = keys;
    /**
     * Returns all the locks in redis which are under this Actionhero namespace.  Potentially slow.
     */
    async function locks() {
        return client().keys(cache.lockPrefix + "*");
    }
    cache.locks = locks;
    /**
     * Returns the number of keys in redis which are under this Actionhero namespace.  Potentially very slow.
     */
    async function size() {
        const keys = await cache.keys();
        let length = 0;
        if (keys) {
            length = keys.length;
        }
        return length;
    }
    cache.size = size;
    /**
     * Removes all keys in redis which are under this Actionhero namespace.  Potentially very slow.
     */
    async function clear() {
        const keys = await cache.keys();
        const jobs = [];
        keys.forEach((key) => {
            jobs.push(client().del(key));
        });
        await Promise.all(jobs);
        return true;
    }
    cache.clear = clear;
    /**
     * Write the current concents of redis (only the keys in Actionhero's namespace) to a file.
     */
    async function dumpWrite(file) {
        const data = {};
        const jobs = [];
        const keys = await cache.keys();
        keys.forEach((key) => {
            jobs.push(client()
                .get(key)
                .then((content) => {
                data[key] = content;
            }));
        });
        await Promise.all(jobs);
        fs.writeFileSync(file, JSON.stringify(data));
        return keys.length;
    }
    cache.dumpWrite = dumpWrite;
    /**
     * Load in contents for redis (and api.cache) saved to a file
     * Warning! Any existing keys in redis (under this Actionhero namespace) will be removed.
     */
    async function dumpRead(file) {
        const jobs = [];
        await cache.clear();
        const fileData = fs.readFileSync(file).toString();
        const data = JSON.parse(fileData);
        const count = Object.keys(data).length;
        const saveDumpedElement = async (key, content) => {
            const parsedContent = JSON.parse(content);
            await client().set(key, content);
            if (parsedContent.expireTimestamp) {
                const expireTimeSeconds = Math.ceil((parsedContent.expireTimestamp - new Date().getTime()) / 1000);
                await client().expire(key, expireTimeSeconds);
            }
        };
        Object.keys(data).forEach((key) => {
            const content = data[key];
            jobs.push(saveDumpedElement(key, content));
        });
        await Promise.all(jobs);
        return count;
    }
    cache.dumpRead = dumpRead;
    /**
     * Load an item from the cache.  Will throw an error if the item named by `key` cannot be found.
     * Automatically handles `api.cache.redisPrefix`
     */
    async function load(key, options = {}) {
        let cacheObj;
        let lockOk = await cache.checkLock(key, options.retry);
        if (lockOk !== true) {
            throw new Error(index_1.i18n.localize("actionhero.cache.objectLocked"));
        }
        let cachedStringifiedObjet = await client().get(`${cache.redisPrefix}${key}`);
        try {
            cacheObj = JSON.parse(cachedStringifiedObjet);
        }
        catch (e) { }
        if (!cacheObj) {
            throw new Error(index_1.i18n.localize("actionhero.cache.objectNotFound"));
        }
        if (cacheObj.expireTimestamp &&
            cacheObj.expireTimestamp < new Date().getTime()) {
            throw new Error(index_1.i18n.localize("actionhero.cache.objectExpired"));
        }
        const lastReadAt = cacheObj.readAt;
        let expireTimeSeconds;
        cacheObj.readAt = new Date().getTime();
        if (cacheObj.expireTimestamp) {
            if (options.expireTimeMS) {
                cacheObj.expireTimestamp = new Date().getTime() + options.expireTimeMS;
                expireTimeSeconds = Math.ceil(options.expireTimeMS / 1000);
            }
            else {
                expireTimeSeconds = Math.floor((cacheObj.expireTimestamp - new Date().getTime()) / 1000);
            }
        }
        lockOk = await cache.checkLock(key, options.retry);
        if (lockOk !== true) {
            throw new Error(index_1.i18n.localize("actionhero.cache.objectLocked"));
        }
        await client().set(cache.redisPrefix + key, JSON.stringify(cacheObj));
        if (expireTimeSeconds) {
            await client().expire(cache.redisPrefix + key, expireTimeSeconds);
            return {
                key,
                value: cacheObj.value,
                expireTimestamp: cacheObj.expireTimestamp,
                createdAt: cacheObj.createdAt,
                lastReadAt,
            };
        }
        else {
            return {
                key,
                value: cacheObj.value,
                expireTimestamp: cacheObj.expireTimestamp,
                createdAt: cacheObj.createdAt,
                lastReadAt,
            };
        }
    }
    cache.load = load;
    /**
     * Delete an item in the cache.  Will throw an error if the item named by `key` is locked.
     * Automatically handles `api.cache.redisPrefix`
     */
    async function destroy(key) {
        const lockOk = await cache.checkLock(key, null);
        if (!lockOk) {
            throw new Error(index_1.i18n.localize("actionhero.cache.objectLocked"));
        }
        const count = await client().del(cache.redisPrefix + key);
        let response = true;
        if (count !== 1) {
            response = false;
        }
        return response;
    }
    cache.destroy = destroy;
    /**
     * Save an item in the cache.  If an item is already in the cache with the same key, it will be overwritten.  Throws an error if the object is already in the cache and is locked.
     * Automatically handles `api.cache.redisPrefix`
     */
    async function save(key, value, expireTimeMS) {
        let expireTimeSeconds = null;
        let expireTimestamp = null;
        if (expireTimeMS !== null) {
            expireTimeSeconds = Math.ceil(expireTimeMS / 1000);
            expireTimestamp = new Date().getTime() + expireTimeMS;
        }
        const cacheObj = {
            value: value,
            expireTimestamp: expireTimestamp,
            createdAt: new Date().getTime(),
            readAt: null,
        };
        const lockOk = await cache.checkLock(key, null);
        if (!lockOk) {
            throw new Error(index_1.i18n.localize("actionhero.cache.objectLocked"));
        }
        await client().set(cache.redisPrefix + key, JSON.stringify(cacheObj));
        if (expireTimeSeconds) {
            await client().expire(cache.redisPrefix + key, expireTimeSeconds);
        }
        return true;
    }
    cache.save = save;
    /**
     * Push an item to a shared queue/list in redis.
     * Automatically handles `api.cache.redisPrefix`
     */
    async function push(key, item) {
        const object = JSON.stringify({ data: item });
        await client().rpush(cache.redisPrefix + key, object);
        return true;
    }
    cache.push = push;
    /**
     * Pop (get) an item to a shared queue/list in redis.
     * Automatically handles `api.cache.redisPrefix`
     */
    async function pop(key) {
        const object = await client().lpop(cache.redisPrefix + key);
        if (!object) {
            return null;
        }
        const item = JSON.parse(object);
        return item.data;
    }
    cache.pop = pop;
    /**
     * Check how many items are stored in a shared queue/list in redis.
     */
    async function listLength(key) {
        return client().llen(cache.redisPrefix + key);
    }
    cache.listLength = listLength;
    /**
     * Lock an item in redis (can be a list or a saved item) to this Actionhero process.
     */
    async function lock(key, expireTimeMS = cache.lockDuration) {
        const lockOk = await cache.checkLock(key, null);
        if (!lockOk) {
            return false;
        }
        const result = await client().setnx(cache.lockPrefix + key, lockName());
        if (!result) {
            return false;
        } // value was already set, so we cannot obtain the lock
        await client().expire(cache.lockPrefix + key, Math.ceil(expireTimeMS / 1000));
        return true;
    }
    cache.lock = lock;
    /**
     * Unlock an item in redis (can be a list or a saved item) which was previously locked by this Actionhero process.
     */
    async function unlock(key) {
        const lockOk = await cache.checkLock(key, null);
        if (!lockOk) {
            return false;
        }
        await client().del(cache.lockPrefix + key);
        return true;
    }
    cache.unlock = unlock;
    async function checkLock(key, retry = false, startTime = new Date().getTime()) {
        const lockedBy = await client().get(cache.lockPrefix + key);
        if (lockedBy === lockName() || lockedBy === null) {
            return true;
        }
        else {
            const delta = new Date().getTime() - startTime;
            if (!retry || delta > retry) {
                return false;
            }
            await index_1.utils.sleep(cache.lockRetry);
            return cache.checkLock(key, retry, startTime);
        }
    }
    cache.checkLock = checkLock;
})(cache = exports.cache || (exports.cache = {}));
