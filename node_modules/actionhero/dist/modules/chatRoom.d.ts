import { Connection } from "./../index";
import * as RedisModule from "../modules/redis";
export declare namespace chatRoom {
    /**
     * Middleware definition for processing chat events.  Can be of the
     *
     * ```js
     *  var chatMiddleware = {
     *    name: 'chat middleware',
     *    priority: 1000,
     *    join: (connection, room) => {
     *      // announce all connections entering a room
     *      api.chatRoom.broadcast({}, room, 'I have joined the room: ' + connection.id, callback)
     *    },
     *    leave:(connection, room, callback) => {
     *      // announce all connections leaving a room
     *      api.chatRoom.broadcast({}, room, 'I have left the room: ' + connection.id, callback)
     *    },
     *    // Will be executed once per client connection before delivering the message.
     *    say: (connection, room, messagePayload) => {
     *      // do stuff
     *      log(messagePayload)
     *    },
     *    // Will be executed only once, when the message is sent to the server.
     *    onSayReceive: (connection, room, messagePayload) => {
     *      // do stuff
     *      log(messagePayload)
     *    }
     * }
     * api.chatRoom.addMiddleware(chatMiddleware)
     * ```
     */
    interface ChatMiddleware {
        /**Unique name for the middleware. */
        name: string;
        /**Module load order. Defaults to `api.config.general.defaultMiddlewarePriority`. */
        priority?: number;
        /**Called when a connection joins a room. */
        join?: Function;
        /**Called when a connection leaves a room. */
        leave?: Function;
        /**Called when a connection says a message to a room. */
        onSayReceive?: Function;
        /**Called when a connection is about to receive a say message. */
        say?: Function;
    }
    interface ChatPubSubMessage extends RedisModule.redis.PubSubMessage {
        messageType: string;
        serverToken: string;
        serverId: string | number;
        message: any;
        sentAt: number;
        connection: {
            id: string;
            room: string;
        };
    }
    /**
     * Add a middleware component to connection handling.
     */
    function addMiddleware(data: ChatMiddleware): Promise<void>;
    /**
     * List all chat rooms created
     */
    function list(): Promise<Array<string>>;
    /**
     * Add a new chat room.  Throws an error if the room already exists.
     */
    function add(room: string): Promise<number>;
    /**
     * Remove an existing chat room.  All connections in the room will be removed.  Throws an error if the room does not exist.
     */
    function destroy(room: string): Promise<void>;
    /**
     * Check if a room exists.
     */
    function exists(room: string): Promise<boolean>;
    /**
     * Configures what properties of connections in a room to return via `api.chatRoom.roomStatus`
     */
    function sanitizeMemberDetails(memberData: any): Promise<{
        id: any;
        joinedAt: any;
    }>;
    /**
     * Learn about the connections in the room.
     * Returns a hash of the form { room: room, members: cleanedMembers, membersCount: count }.  Members is an array of connections in the room sanitized via `api.chatRoom.sanitizeMemberDetails`
     */
    function roomStatus(room: string): Promise<{
        [key: string]: any;
    }>;
    /**
     * An overwrite-able method which configures what properties of connections in a room are initially stored about a connection when added via `api.chatRoom.addMember`
     */
    function generateMemberDetails(connection: Connection): Promise<{
        id: string;
        joinedAt: number;
        host: string;
    }>;
    /**
     * Add a connection (via id) to a room.  Throws errors if the room does not exist, or the connection is already in the room.  Middleware errors also throw.
     */
    function addMember(connectionId: string, room: string): Promise<any>;
    /**
     * Remote a connection (via id) from a room.  Throws errors if the room does not exist, or the connection is not in the room.  Middleware errors also throw.
     * toWaitRemote: Should this method wait until the remote Actionhero server (the one the connection is connected too) responds?
     */
    function removeMember(connectionId: string, room: string, toWaitRemote?: boolean): Promise<any>;
    /**
     * Send a message to all clients connected to this room
     * - connection should either be a real client you are emulating (found in api.connections) or just `{}` for a mock
     * - room is the string name of an already-existing room
     * - message can be anything: string, json, object, etc
     */
    function broadcast(connection: Connection | {
        [key: string]: any;
    }, room: string, message: any): Promise<any>;
}
