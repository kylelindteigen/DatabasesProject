"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("uuid");
const node_resque_1 = require("node-resque");
const index_1 = require("./../index");
var specHelper;
(function (specHelper) {
    /**
     * Generate a connection to use in your tests
     */
    async function buildConnection() {
        return index_1.api.specHelper.Connection.createAsync();
    }
    specHelper.buildConnection = buildConnection;
    /**
     * Run an action via the specHelper server.
     */
    async function runAction(actionName, input = {}) {
        let connection;
        if (input.id && input.type === "testServer") {
            connection = input;
        }
        else {
            connection = await specHelper.buildConnection();
            connection.params = input;
        }
        connection.params.action = actionName;
        connection.messageId = connection.params.messageId || uuid.v4();
        const response = await new Promise((resolve) => {
            index_1.api.servers.servers.testServer.processAction(connection);
            connection.actionCallbacks[connection.messageId] = resolve;
        });
        return response;
    }
    specHelper.runAction = runAction;
    /**
     * Mock a specHelper connection requesting a file from the server.
     */
    async function getStaticFile(file) {
        const connection = await specHelper.buildConnection();
        connection.params.file = file;
        connection.messageCount = uuid.v4();
        const response = await new Promise((resolve) => {
            index_1.api.servers.servers.testServer.processFile(connection);
            connection.actionCallbacks[connection.messageId] = resolve;
        });
        return response;
    }
    specHelper.getStaticFile = getStaticFile;
    /**
     * Use the specHelper to run a task.
     * Note: this only runs the task's `run()` method, and no middleware.  This is faster than api.specHelper.runFullTask.
     */
    async function runTask(taskName, params) {
        return index_1.api.tasks.tasks[taskName].run(params);
    }
    specHelper.runTask = runTask;
    /**
     * Use the specHelper to run a task.
     * Note: this will run a full Task worker, and will also include any middleware.  This is slower than api.specHelper.runTask.
     */
    async function runFullTask(taskName, params) {
        const worker = new node_resque_1.Worker({
            connection: {
                redis: index_1.api.redis.clients.tasks,
            },
            queues: index_1.config.tasks.queues || ["default"],
        }, index_1.api.tasks.jobs);
        try {
            await worker.connect();
            const result = await worker.performInline(taskName, params);
            await worker.end();
            return result;
        }
        catch (error) {
            try {
                worker.end();
            }
            catch (error) { }
            throw error;
        }
    }
    specHelper.runFullTask = runFullTask;
    /**
     * Use the specHelper to find enqueued instances of a task
     * This will return an array of instances of the task which have been enqueued either in the normal queues or delayed queues
     * If a task is enqueued in a delayed queue, it will have a 'timestamp' property
     * i.e. [ { class: 'regularTask', queue: 'testQueue', args: [ [Object] ] } ]
     */
    async function findEnqueuedTasks(taskName) {
        let found = [];
        // normal queues
        const queues = await index_1.api.resque.queue.queues();
        for (const i in queues) {
            const q = queues[i];
            const length = await index_1.api.resque.queue.length(q);
            const batchFound = await index_1.task.queued(q, 0, length + 1);
            let matches = batchFound.filter((t) => t.class === taskName);
            matches = matches.map((m) => {
                m.timestamp = null;
                return m;
            });
            found = found.concat(matches);
        }
        // delayed queues
        const allDelayed = await index_1.api.resque.queue.allDelayed();
        for (const timestamp in allDelayed) {
            let matches = allDelayed[timestamp].filter((t) => t.class === taskName);
            matches = matches.map((m) => {
                m.timestamp = parseInt(timestamp);
                return m;
            });
            found = found.concat(matches);
        }
        return found;
    }
    specHelper.findEnqueuedTasks = findEnqueuedTasks;
    /**
     * Delete all enqueued instances of a task, both in all the normal queues and all of the delayed queues
     */
    async function deleteEnqueuedTasks(taskName, params) {
        const queues = await index_1.api.resque.queue.queues();
        for (const i in queues) {
            const q = queues[i];
            await index_1.api.resque.queue.del(q, taskName, [params]);
            await index_1.api.resque.queue.delDelayed(q, taskName, [params]);
        }
    }
    specHelper.deleteEnqueuedTasks = deleteEnqueuedTasks;
})(specHelper = exports.specHelper || (exports.specHelper = {}));
